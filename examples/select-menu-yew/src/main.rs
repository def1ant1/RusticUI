use mui_material::select::SelectOption;
use select_menu_shared::{
    enterprise_theme, fetch_regions, props_from_options, render_select_markup, selection_summary,
    to_select_options, AUTOMATION_ID,
};
#[cfg(feature = "ssr")]
use select_menu_shared::ssr_shell;
use yew::prelude::*;

/// High-touch Yew component exercising async loading, SSR friendly rendering
/// and fully controlled select state. The example intentionally contains
/// extensive inline documentation so downstream teams can replicate the setup
/// without spelunking through multiple files.
#[function_component(App)]
fn app() -> Html {
    // Options resolved from the shared async loader. We keep them in a Yew state
    // hook so rerenders occur automatically once the data arrives.
    let options = use_state(Vec::<SelectOption>::new);
    // Selected index is controlled via state. The value starts as `None` until
    // the async loader resolves, at which point we synchronise the state machine.
    let selected = use_state(|| None::<usize>);
    // Popover open flag is also controlled to demonstrate how enterprise apps
    // might gate the menu behind analytics or RBAC checks.
    let open = use_state(|| false);
    let summary_handle = use_state(|| "Select a region to pin traffic".to_string());

    // Fetch options exactly once on the client. The effect is guarded behind the
    // `csr` feature so the server build does not pull in wasm-only dependencies.
    #[cfg(feature = "csr")]
    {
        let options = options.clone();
        let selected = selected.clone();
        use_effect_with((), move |_| {
            wasm_bindgen_futures::spawn_local(async move {
                let regions = fetch_regions().await;
                let opts = to_select_options(&regions);
                if !opts.is_empty() {
                    selected.set(Some(0));
                }
                options.set(opts);
            });
            || ()
        });
    }

    // Toggle handlers keep business logic declarative and reusable from tests.
    let toggle_open = {
        let open = open.clone();
        Callback::from(move |_| open.set(!*open))
    };
    let cycle_selection = {
        let options = options.clone();
        let selected = selected.clone();
        Callback::from(move |_| {
            let len = options.len();
            if len == 0 {
                return;
            }
            let next = match *selected {
                Some(current) => (current + 1) % len,
                None => 0,
            };
            selected.set(Some(next));
        })
    };

    // Derive the select markup via the shared renderer so the same HTML is used
    // during SSR and hydration. Using `Html::from_html_unchecked` is safe here
    // because the renderer returns trusted markup.
    let select_markup = {
        let summary_handle = summary_handle.clone();
        if options.is_empty() {
            summary_handle.set("Loading datacenters…".into());
            html! { <p data-automation="select-menu-loading">{"Loading datacenters…"}</p> }
        } else {
            let props = props_from_options(
                "Primary replication region",
                AUTOMATION_ID,
                &*options,
            );
            let summary = selection_summary(&props, *selected);
            let html = render_select_markup(&props, *open, *selected);
            let markup = Html::from_html_unchecked(AttrValue::from(html));
            // Persist the summary for the rendered section.
            summary_handle.set(summary);
            markup
        }
    };

    let theme = enterprise_theme();
    let summary_text = summary_handle.clone();
    let container_style = format!(
        "min-height:100vh;display:flex;align-items:center;justify-content:center;background:{};padding:32px;",
        theme.palette.background_default
    );
    let panel_style = format!(
        "max-width:720px;display:flex;flex-direction:column;gap:16px;background:{};padding:24px;border-radius:{}px;box-shadow:0 12px 40px rgba(0,0,0,0.35);color:{};",
        theme.palette.background_paper,
        theme.joy.radius,
        theme.palette.text_primary
    );

    html! {
        <div
            style={container_style}
            data-automation="select-menu-yew-shell"
        >
            <div style={panel_style}>
                <header>
                    <h1 style="margin:0;font-size:1.75rem;">{"RusticUI Select Menu — Yew"}</h1>
                    <p style="margin:4px 0 0;max-width:48ch;">
                        {"The select renders with fully controlled state, deterministic data-* hooks, and ARIA attributes generated by the headless state machine."}
                    </p>
                </header>
                <section style="display:flex;gap:8px;flex-wrap:wrap;">
                    <button
                        type="button"
                        onclick={toggle_open}
                        data-automation="select-menu-toggle-open"
                    >
                        {if *open {"Close menu"} else {"Open menu"}}
                    </button>
                    <button
                        type="button"
                        onclick={cycle_selection}
                        data-automation="select-menu-cycle"
                    >
                        {"Cycle selection"}
                    </button>
                </section>
                <p
                    aria-live="polite"
                    data-automation="select-menu-selection"
                    style="margin:0;font-weight:500;"
                >
                    {(*summary_text).clone()}
                </p>
                <section data-automation="select-menu-rendered">
                    {select_markup}
                </section>
            </div>
        </div>
    }
}

#[cfg(feature = "csr")]
fn main() {
    // Hydrate the server markup when present. The renderer uses the same HTML
    // generation helpers so hydration order and automation hooks line up.
    yew::Renderer::<App>::new().hydrate();
}

#[cfg(feature = "ssr")]
#[tokio::main]
async fn main() {
    // Server side rendering path used by CI and documentation snapshots.
    let regions = fetch_regions().await;
    let options = to_select_options(&regions);
    let props = props_from_options("Primary replication region", AUTOMATION_ID, &options);
    let html = render_select_markup(&props, true, Some(0));
    let theme = enterprise_theme();
    println!("{}", ssr_shell(&html, &theme));
}
